# 2장. 아키텍처 개요

## 2.1 네 개의 영역

표현, 응용, 도메인, 인프라스트럭처는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.

![architecture](https://imgur.com/tyTvHpH.png)

**표현(또는 UI) 영역**은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다. 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다.

웹 애플리케이션에서 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고, REST API를 호출하는 외부 시스템일 수도 있다.

사용자의 요청을 해석해서 응용 서비스에 전달하고, 응용 서비스의 실행 결과를 사용자가 이해할 수 있는 형식으로 변환하여 응답한다.

표현 영역을 통해 사용자의 요청을 전달받는 **응용 영역**은 시스템이 사용자에게 제공해야 할 기능을 구현한다.

#### 주문 취소 기능을 제공하는 응용 서비스

```java
public class CancelOrderService {

    @Transactional
    public void cancelOrder(String orderId) {
        Order order = findOrderById(orderId);
        if (order == null) throw new OrderNotFoundException(orderId);
        // 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임한다.
        order.cancel();
    }
}
```

**응용 영역**은 도메인 모델을 이용해서 사용자에게 제공할 기능을 구현한다. 실제 도메인 로직 구현은 도메인 모델에 위임한다.

**도메인 영역**은 도메인 모델을 구현한다. 도메인 모델은 도메인의 핵심 로직을 구현한다.

**인프라스트럭처 영역**은 구현 기술에 대한 것을 다룬다.

- RDBMS 연동
- 메시징 큐에 메시지 전송/수신
- 데이터 연동
- SMTP 이용한 메일 발송 기능 구현
- HTTP 클라이언트를 이용하여 REST API 호출
  **인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.**

도메인, 응용, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.

- ex) DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용하여 데이터를 조회한다.

<br>

## 2.2 계층 구조 아키텍처

### 네 영역을 구성할 때 많이 사용하는 아키텍처

표현 -> 응용 -> 도메인 -> 인프라스트럭처

도메인의 복잡도에 따라 응용과 도메인을 분리하기도 하고 한 계층으로 합치기도 한다.

⭐ **계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.**

- ex) 표현 계층은 응용 계층에 의존하지만 응용 계층은 표현 계층을 몰라도 됨

계층 구조를 엄격하게 적용한다면 바로 아래 계층에만 의존을 가져야 하지만 **구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 한다.**

### 인프라스트럭처에 의존하면 발생하는 두 가지 문제점

1. 테스트 어려움
2. 기능 확장의 어려움

두 문제를 해소하는 방법 => **DIP**

<br>

## 2.3 DIP

> **DIP(Dependency Inversion Principle)**
>
> 의존 역전 원칙

#### 고수준 모듈: 의미 있는 단일 기능을 제공하는 모듈

#### 저수준 모듈: 하위 기능을 실제로 구현

고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데 고수준 모듈이 저수준 모듈을 사용하면 앞서 언급했던 두 가지 문제, 구현 변경과 테스트가 어렵다는 문제가 발생한다.

⭐ DIP는 이 문제를 해결하기 위해 **추상화한 인터페이스**를 사용하여 저수준 모듈이 고수준 모듈에 의존하도록 바꿔준다.

![2.3.dip](https://imgur.com/WusQ90j.png)

만약 CalculateDiscountService가 저수준 모듈에 직접 의존했다면 저수준 모델이 만들어지기 전까지 테스트를 할 수 없었겠지만 CustomerRepository와 RuleDiscounter는 인터페이스이므로 **대역 객체**(Mocking)를 사용해서 테스트를 진행할 수 있다.

**DIP를 적용하여 구현 교체가 어렵다는 것과 테스트가 어려운 문제를 해소할 수 있다.**

### 2.3.1 DIP 주의사항

DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.

DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다.

### 2.3.2 DIP와 아키텍처

인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈이다.

계층형 구조에서는 인프라스트럭처 영역이 최하단에 위치하지만 DIP를 적용한 아키텍처에서는 인프라스트럭처 영역이 응용/도메인 영역에 의존(상속)하는 구조가 된다.

**DIP를 항상 적용할 필요는 없다.** 상황에 따라 도메인에 코드를 포함시키는게 효과적일 수도 있고 추상화 할 대상이 명확하지 않을 수도 있다. DIP의 이점을 얻는 수준에서 적용 범위를 검토해 보자.

<br>

## 2.4 도메인 영역의 주요 구성요소

도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심 로직을 구현한다.

#### ⭐ 도메인 영역의 주요 구성요소

| **요소**       | **설명**                                                                                                                                                        |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Entity         | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.                           |
| Value          | 고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 엔티티 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다. |
| Aggregate      | 애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. ex) 주문 애그리거트: (Order 엔티티, OrderLine 밸류, Orderer 밸류)                       |
| Repository     | 도메인 모델의 영속성을 처리한다.                                                                                                                                |
| Domain Service | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류와 연관되어 로직이 복잡해지면 도메인 서비스에서 로직을 구현한다.              |

### 2.4.1 엔티티와 밸류

도메인 모델의 엔티티와 DB 테이블의 엔티티는 다르다. **도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 제공한다.**

도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보다는 데이터와 함께 기능을 제공하는 객체이다. 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.

```java
public class Order {

    // 주문 도메인의 데이터
    private OrderNo number;
    private Orderer orderer;
    private ShippingInfo shippingInfo;

    // 도메인 모델 엔티티는 도메인 기능도 함께 제공
    public void changeShippingInfo(ShippingInfo shippingInfo) {
        ...
    }
}
```

두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다. 주문자를 표현하는 Orderer는 밸류 타입으로 아래와 같이 주문자의 이름과 이메일 데이터를 포함한다.

```java
public class Orderer {

    private String name;
    private String email;
}
```

> RDBMS와 같은 관계형 데이터베이스는 밸류 타입을 제대로 표현하기 힘들다. Order 안에 Orderer 정보를 함께 저장하거나 Order와 Orderer를 각각 개별 데이터로 분리하여 저장해야 한다.

⭐ **밸류 타입은 불변으로 구현할 것을 권장하며, 이는 엔티티의 밸류 타입 데이터를 변경할 때는 객체 자체를 완전히 교체한다는 것을 의미한다.**

```java
public class Order {

    private ShippingInfo shippingInfo;

    // 도메인 모델 엔티티는 도메인 기능도 함께 제공
    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        checkShippingInfoChangeable();
         // 밸류 타입 데이터 변경 시 객체 자체를 완전히 교체한다.
        setShippingInfo(newShippingInfo);
    }

    private void setShippingInfo(ShippingInfo newShippingInfo) {
        if (newShippingInfo == null) throw new IllegalArgumentException();
        // 밸류 타입 데이터 변경 시 객체 자체를 완전히 교체한다.
        this.shippingInfo = newShippingInfo;
    }
}
```

### 2.4.2 애그리거트

애그리거트는 관련 객체를 하나로 묶은 군집이다. 하위 개념을 표현한 모델들을 하나로 묶어서 상위 개념으로 표현할 수 있다.

- ex) 주문: (주문, 배송지 정보, 주문자, 주문 목록, 총 결제 금액, ...)

개별 객체 간의 관계가 아닌 하나로 묶인 애그리거트 간의 관계를 바라보면 전체적인 도메인 모델을 이해하고 관리하기 용이해진다.

애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖는다. 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다. 이렇게 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 캡슐화할 수 있도록 돕는다.

### 2.4.3 리포지터리

도메인 객체를 지속적으로 사용하려면 물리적인 저장소에 도메인 객체를 보관해야 하는데, 이를 위한 도메인 모델이 Repository이다. 엔티티와 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.

리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.

```java
public interface OrderRepository {

    Order findByNumber(OrderNumber number);
    void save(Order order);
    void delete(Order order);
}
```

메서드를 보면 대상을 조회하고 저장하는 단위가 **애그리거트 루트**인 것을 알 수 있다.

도메인 모델을 사용해야 하는 코드는 리포지터리를 통해서 도메인 객체를 구한 뒤에 도메인 객체의 기능을 실행한다.

```java
public class CancelOrderService {

    private OrderRepository orderRepository;

    public void cancel(OrderNumber number) {
        // 1단계 - 도메인 객체 조회
        Order order = orderRepository.findByNumber(number);
        if (order == null) throw nuew NoOrderException(number);
        // 2단계 - 도메인 객체 기능 실행
        order.cancel();
    }
}
```

도메인 모델 관점에서 **리포지터리**는 도메인 객체를 영속화하는 데 필요한 기능을 추상화한 것으로 **고수준 모델**에 속한다. 기반 기술을 이용해서 **리포지터리를 구현한 클래스**는 **저수준 모듈**로 인프라스트럭처 영역에 속한다.

- Repository 인터페이스 -> 도메인 모델 영역
- Repository 구현 클래스 -> 인프라스트럭처 영역

#### 응용 서비스와 Repository가 밀접한 연관이 있는 이유

- 응용 서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다.
- 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술의 영향을 받는다.

리포지터리 구현 방법은 선택한 구현 기술에 따라 달라진다.
