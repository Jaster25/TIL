# 쿠버네티스 감잡기 - 왕초보편

[유튜브 - 쿠버네티스 감잡기 - 왕초보편](https://www.youtube.com/playlist?list=PLeWIi-8hd-6WRfohXdF93aPfbaJdf6h96) 강의 정리

<br>

## 1강 - **쿠버네티스, 컨테이너, 도커 개념 감잡기**

### **컨테이너란?**

애플리케이션을 실행하는 데 필요한 모든 파일, 라이브러리, 설정 등을 하나의 패키지로 묶어 어떤 환경에서도 일관되게 실행될 수 있도록 만든 기술

#### **컨테이너 기술 특징**

1. **경량화**
   - 컨테이너는 OS를 공유하고, 필요한 최소한의 리소스만 사용하기 때문에 가볍다. 이로 인해 더 많은 애플리케이션을 하나의 서버에 실행할 수 있다.
2. **독립적 실행**
   - 컨테이너는 서로 격리되어 있어 한 컨테이너의 문제가 다른 컨테이너에 영향을 주지 않는다. → 안정성 향상
3. **이식성**
   - 컨테이너는 애플리케이션과 그 환경을 함께 묶어 어디서든 동일하게 실행할 수 있다.

### 도커란?

컨테이너를 쉽게 사용할 수 있게 만든 도구이자 플랫폼

#### **도커의 주요 역할**

- 컨테이너 이미지 생성
- 컨테이너 실행 및 관리
- 이식성 및 버전 관리

컨테이너 기술은 애플리케이션을 어떤 환경에서도 동일하게 실행할 수 있게 해주는 기술이고, 도커는 이를 편리하게 만들고 관리하는 도구

### 도커가 아닌 쿠버네티스인 이유?

**도커는 개별 컨테이너**를 쉽게 만들고 실행하는데 유용하지만, 많은 컨테이너를 클러스터 환경에서 자동화하고 **확장하여 운영할 때는 쿠버네티스**가 훨씬 효율적이다.

대규모 애플리케이션을 안정적으로 운영하기 위해서는 컨테이너 오케스트레이션 기능을 제공하는 쿠버네티스가 유리하다.

#### 컨테이너 이미지 실습

```bash
docker run —name web -d -p 80:80 nginx
docker run —name webserver -d -p 8080:80 httpd
docker run —name webserver2 -d -p 8001:80 httpd
```

#### 쿠버네티스 역할

1. **자동 배포 및 관리**

   애플리케이션을 여러 서버에 분산해 자동으로 배포하고, 필요한 경우 업데이트나 롤백을 쉽게 수행할 수 있도록 지원

2. **확장성 관리**

   사용량이 증가하거나 감소할 때 애플리케이션 인스턴스를 자동으로 늘리거나 줄여, 적절한 자원을 유지

3. **장애 복구**

   애플리케이션이 오류로 중단될 경우 자동으로 재시작하거나, 오류가 난 컨테이너를 다른 노드로 옮겨 문제없이 서비스가 유지되도록 한다

4. **리소스 관리**

   서버 자원을 효율적으로 분배하여 애플리케이션이 최적의 성능을 유지하도록 지원

### QnA

1. 컨테이너 기술에서 클러스터와 노드의 차이?

**클러스터(Cluster)**

- 컨테이너 실행을 위한 서버(노드)들의 집합
- 단일 서버가 아닌 여러 노드가 묶여 하나의 큰 시스템처럼 동작하는 그룹

**노드**

- 클러스터를 구성하는 개별 서버
- 컨테이너가 실제로 실행되는 단위

```bash
[ Cluster ]
   ├── Node 1
   │     ├── Container A  → (Image: nginx:latest)
   │     └── Container B  → (Image: redis:7)
   │
   ├── Node 2
   │     ├── Container C  → (Image: myapp:v1)
   │     └── Container D  → (Image: mysql:8.0)
   │
   └── Node 3
         ├── Container E  → (Image: myapp:v1)
         └── Container F  → (Image: nginx:latest)

```

- 이미지는 실행 파일(설치 패키지)
- 컨테이너는 그걸 실행한 실제 프로그램
- 노드는 컨테이너가 뛰는 서버
- 클러스터는 여러 노드를 통합 관리하는 그룹

<br>

## 2강 - **컨테이너 이미지, pull 주소 구조 감잡기**

> 컨테이너 이미지를 사용해 컨테이너를 실행한다?

### 컨테이너 기술

**애플리케이션과 그 실행 환경을 ‘컨테이너’라는 가상화된 공간에 패키징하는 기술**

컨테이너는 기존 가상 머신과는 다르게, **OS 커널을 공유**하면서 **서로 독립된 실행 환경을 제공**하여 더 경량화되고 빠르게 동작할 수 있다. 즉, 컨테이너는 애플리케이션 코드, 라이브러리, 종속성 등을 포함해 이를 배포할 때 일관되게 작동하도록 해준다.

### 컨테이너 이미지

**컨테이너 이미지는 컨테이너 실행에 필요한 모든 파일과 설정이 포함된 ‘템플릿’과 같은 역할**

이 이미지는 컨테이너의 상태와 환경을 일관되게 유지하는 데 사용되며, 개발자들이 구축한 환경 그대로를 배포할 수 있게 도와준다.

#### 주요 특징

- **불변성**
  컨테이너 이미지는 **읽기 전용**으로 저장되며, 생성 후에는 수정되지 않기 때문에 일관된 환경 보장
- **계층화**
  이미지는 여러 계층으로 이루어져 있으며, 각 계층은 특정 작업을 나타낸다.
  ex) 첫 계층은 운영체제, 그 위는 라이브러리 계층, 마지막은 애플리케이션 계층
  이 계층화 덕분에 이미지의 일부만 변경해도 전체 이미지를 다시 생성할 필요가 없다.
- **배포 용이성**
  컨테이너 이미지는 Docker Hub와 같은 **이미지 레지스트리**에 저장할 수 있어, 언제 어디서나 컨테이너로 실행할 수 있다.

### 컨테이너 이미지 pull 구조

```bash
docker pull redis
```

![docker-image-pull](https://imgur.com/fJrw3p5.png)

층을 하나씩 가져와서 완전한 이미지를 가져온다.

`pull` 할 때 사용하는 주소는 이미지가 **어디에 저장되어 있는지**, **어떤 이미지인지**를 명확히 지정하는 구조로 이루어져 있다.

```bash
<레지스트리 정보>/<이미지 이름>:<태그>
```

- <레지스트리 정보> 생략: 도커 허브
- <태그> 생략: latest 버전

```bash
docker pull jsregistry/myimg:1.0
docker pull nginx:1.24.3
```

<br>

## 3강 - 쿠버네티스 구조와 용어 감잡기

### 쿠버네티스 구조와 용어 설명

**쿠버네티스는 컨테이너화된 애플리케이션을 대규모로 배포하고 관리하기 위한 분산 시스템**

- **클러스터**: 컨테이너화된 애플리케이션을 관리하기 위한 컴퓨팅 리소스의 집합
- **노드**: 컨테이너를 실행하는 워커 머신으로, Pod가 배포되고 애플리케이션이 동작하는 실제 실행 환경
- **컨트롤 플레인**: 클러스터를 관리하고 조율하는 두뇌 역할

#### 클러스터

쿠버네티스 클러스터는 **여러 개의 노드로 구성**되며, **하나의 통합된 시스템처럼 작동**한다.

클러스터는 **다양한 노드 자원을 하나의 단위로 관리**하며, 애플리케이션의 배포와 관리를 최적화할 수 있는 환경을 제공한다.

구성: 컨트롤 플레인 / 워커 노드

#### 컨트롤 플레인

**클러스터의 상태를 제어하고 조정하는 핵심 구성 요소.**

클러스터의 상태를 관리하며, 애플리케이션이 원하는 대로 배포되고 운영되도록 유지한다.

- **API 서버**: **클러스터와 외부의 모든 요청을 관리하는 진입점**으로, 클러스터 내부의 리소스 상태를 조회하고 수정하는 인터페이스
- **스케쥴러**: 클러스터 내 워커 노드들에 애플리케이션을 배치하는 역할을 하며, 각 노드의 상태와 자원 사용량을 고려하여 최적의 위치를 선정한다.
- **컨트롤러 매니저**: 여러 컨트롤러를 통합 관리하며, 클러스터 내 **리소스가 사용자 지정 상태에 맞게 유지되도록** 한다.
- **etcd**: 모든 클러스터 사태 데이터를 저장하는 키-값 저장소로, **클러스터의 설정과 구성 정보를 영구적으로 보관**한다.

#### 노드

실제로 애플리케이션을 구동하는 클러스터의 구성 요소.

물리적 서버이거나 가상 머신일 수 있으며, 노드들은 워커 노드와 컨트롤 플레인으로 구성된다.

- **컨트롤 플레인(구 마스터 노드)**: 클러스터를 제어하고 관리하는 역할을 맡으며, 컨트롤 플레인에서 설명한 API 서버, 스케쥴러, 컨트롤러 매니저, etcd가 여기 위치한다.
- **워커노드**: 실제 애플리케이션을 구동하는 노드로, 각 애플리케이션의 컨테이너를 포함하는 Pod가 이곳에서 실행된다.
- 구성 요소:
  - **Kubelet**: 워커 노드의 **주요 에이전트**로, **API 서버와 통신하며, 노드에서 파드를 생성하고 유지한다.**
  - **컨테이너 런타임**: 컨테이너를 실행하는 데 필요한 환경을 제공하며, Docker, containerd 등이 이에 해당한다.
  - **kube-proxy**: 쿠버네티스 클러스터에서 서비스 트래픽을 적절한 Pod로 라우팅하고 로드 밸런싱을 수행하는 네트워크 중계자

<br>

## 4강 - 쿠버네티스 클러스터와 통신하는 방법 감잡기

### 쿠버네티스 클러스터 통신하는 방법

1. **Kubectl** ← 가장 일반적이고 공식적인 CLI 도구
2. Kubernetes Dashboard
3. REST API
4. Client Libraries(SDK) 등등

### kubectl이란?

- kubectl은 **클러스터의 API 서버와 통신**한다
- 모든 쿠버네티스 리소스는 API 서버를 통해 관리된다
- 사용자는 kubectl을 통해 명령어를 입력하면 API 서버에 요청을 보내고, 요청 결과를 받는다
- kubectl은 KUBECONFIG 파일을 사용하여 클러스터 접속 정보를 저장한다.

#### kubectl 특징

1. **클러스터 통신 구조**
   - kubectl은 쿠버네티스의 공식 CLI 도구로, 클러스터의 API 서버와 직접 통신한다.
   - 사용자는 kubectl 명령어를 입력하여 요청을 전송하고, API 서버로부터 결과를 수신한다.
2. **kubectl의 kubeconfig 파일**
   - 클러스터 접속 정보를 포함한 설정 제공
   - 기본 경로: ~/.kube/config
3. **kubeconfig 파일 내 주요 정보**
   - API 서버 URL
   - 사용자 인증 정보
   - 네임스페이스 정보

<br>

# 5강 - 쿠버네티스 실습환경 및 kubectl 자동완성 기능

> 도커 데스크탑 활용하기

## 도커 데스크탑 장점

- 쿠버네티스 클러스터 포함
- kubectl 포함

## 추가 환경설정

- kubectl 자동 완성 기능(쿠버네티스 CLI 명령어 자동 완성 기능)
  https://kubernetes.io/ko/docs/reference/kubectl/cheatsheet/
  - 긴 명령어/리소스/경로 탐색 등 tab 키로 자동 완성 및 오타 방지

```bash
source <(kubectl completion zsh)  # 현재 셸에 zsh의 자동 완성 설정
echo '[[ $commands[kubectl] ]] && source <(kubectl completion zsh)' >> ~/.zshrc # 자동 완성을 zsh 셸에 영구적으로 추가한다.

alias k=kubectl
complete -o default -F __start_kubectl k
```

![iterm-sample](https://imgur.com/UD5oB2m.png)

<br>

# 6강 - 쿠버네티스 파드란?

## 도커와 쿠버네티스의 차이점

- 도커에서는 컨테이너를 직접 배포하고 실행
- 쿠버네티스에서는 Pod라는 단위를 사용

### Pod란?

쿠버네티스에서 파드는 컨테이너의 집합으로, 애플리케이션을 실행하는 가장 작은 단위이다.

## Pod의 구조와 기본 개념

- **컨테이너 그룹**
  - Pod는 **하나 이상의 컨테이너를 포함**한다.
  - 동일한 Pod 내 컨테이너들은 네트워크와 스토리지를 공유한다.
- **네트워크**
  - Pod 내부의 컨테이너는 동일한 네트워크 네임스페이스를 공유하며, **localhost를 통해 서로 통신할 수 있다.**
- **스토리지**
  - Pod는 공유 볼륨을 사용하여 데이터를 컨테이너 간에 공유할 수 있다.(볼륨: 파드가 살아있는 동안 사용하는 공유 스토리지)

<br>

# 7강 - 파드의 생애주기와 특징

> 안정적이고 효율적인 클러스터 운영을 위해서

## Pod는 왜 임시적 리소스인가?

1. 의도적으로 짧은 수명을 가지도록 설계
2. 스스로를 관리하지 않음
   - 상위 컨트롤러에 의해 관리됨(ex. Deployment)
   - 장애나 변경 요청에 따라 언제든지 삭제 및 재생성 될 수 있도록
3. 고유한 식별자(UID)를 가짐
4. 내구성을 보장하지 않음

## Pod의 Life Cycle

- create pod
  - pending: Pod가 생성되었지만, 노드에 스케쥴되지 않은 상태
    - running: Pod 노드에 스케쥴되고 모든 컨테이터가 실행 중인 상태
      - terminating
      - succeeded
      - failed
- unknown: Pod의 상태가 쿠버네티스와의 통신 문제로 인해 확인되지 않은 상태

## Pod

- 쿠버네티스에서 파드는 **애플리케이션의 최소 배포 단위**
- 컨테이너를 실행하기 위한 기본 단위

<br>

# 8강 - 쿠버네티스 kubectl 기초 명령어 6개 및 과제

## 기초 명령어

### 1. 간단한 pod 생성

```bash
kubectl run <파드이름> --image=<이미지이름>
kubectl run mypod --image nginx
```

### 2. 클러스터 내 파드 확인

```bash
kubectl get pods # 현재 네임스페이스 내 모든 파드 리스트 표시
kubectl get pods -o wide # 파드 리스트 상세 확인
```

- `-o wide`: 상세 확인 옵션

### 3. 파드 상세 정보 확인

```bash
kubectl describe pod <pod-name> # 특정 파드에 대한 상세 정보 확인
```

### 4. 파드 로그 확인

```bash
kubectl logs <pod-name> # 파드 내 첫 번째 컨테이너의 로그 출력
kubectl logs **-f** <pod-name>
```

- `-f`: 파드 로그 실시간 스트리밍 옵션

### 5. 파드 포트 포워딩

```bash
kubectl port-forward pods/<pod-name> <local-port>:<pod-port>
kubectl port-forward <pod-name> 8080:80
```

### 6. 컨테이너 쉘 접근

```bash
kubectl exec -it pods/mypod -- /bin/bash
```

- `-i`: 입력 전달
- `-t`: 터미널 환경 제공
- 접근 후 종료하는 법
  - 명령어: exit
  - 단축키: Ctrl + D

## 과제

1. 도커 허브에 있는 httpd 이미지를 이용하여 webtest라는 이름을 가진 pod 생성하기

   ![image.png](https://imgur.com/2JQQefO.png)

2. webtest 파드에 접근해서 /usr/local/apache2/htdocs

   ![image.png](https://imgur.com/RDa3Dw1.png)

3. index.html을 수정하기

   ```bash
   # 텍스트 에디터가 존재하지 않아서 vim 설치
   apt-get update
   apt-get install vim -y
   vi index.html
   # i -> 수정 -> esc -> :wq
   ```

   ![image.png](https://imgur.com/zKAw8bd.png)

4. 3000 port로 webtest 파드를 포트포워딩하여 접근 후 새로고침 여러 번 하기

   ![image.png](https://imgur.com/ETc8V0x.png)

   ![image.png](https://imgur.com/vcHtj0N.png)
   수정된 것도 확인

5. 파드 로그를 확인하여 로그에 접근했던 기록 확인하기

   ![image.png](https://imgur.com/Yu3c285.png)

<br>

# 9강 - YAML 파일 구조 파악과 kubectl 사용법

## YAML 파일이란?

- 리소스를 정의하는 기본적인 방법
- 클러스터에 배포할 오브젝트의 상태를 **선언적으로 기술**한다
  - **선언적 기술**: 무엇을 해야 하는지에 초점을 맞춰 기술하는 방식
- 코드 기반으로 클러스터 리소스 관리한다
- 가독성이 높은 계층적 데이터 포맷으로, JSON과 동일한 구조를 표현할 수 있지만 더 간결하다

## 쿠버네티스 YAML 파일 구조

1. **apiVersion**: 리소스의 API 버전 지정(ex: v1, apps/v1)
2. **kind**: 생성할 리소스의 종류 지정(ex: Pod, Deployment, Service, ConfigMap)
3. **metadata**: 리소스의 메타데이터를 설정(name, labels, …)
4. **spec**: 리소스의 구체적인 스펙(사양). 리소스의 동작, 속성, 구성 요소 등 정의

**pod.yaml**

```yaml
apiVersion: v1
kind: Pod
metadata:
	name: nginx-pod
	labels:
		app: nginx # Pod를 그룹화하거나 선택할 때 사용하는 키-값 쌍
spec:
	containers: # Pod 안에서 실행될 컨테이너를 정의
		- name: nginx-container
  		image: nginx:1.21
  		ports:
	  		- containerPort: 80
```

> `-`: YAML 문법에서 리스트를 나타낸다.

![image.png](https://imgur.com/i7YD3rl.png)

```bash
kubectl apply -f pod.yaml # YAML 파일 적용하기
kubectl delete -f pod.yaml # YAML 파일로 배포한 리소스 제거하기
```

![image.png](https://imgur.com/HDLhUiU.png)

<br>

# 10강 - 레플리카셋과 디플로이먼트

## 임시적인 리소스, Pod의 특징

- 의도적으로 짧은 수명을 가지도록 설계
- 스스로를 관리하지 않음
- 고유한 식별자를 가짐
- 내구성을 보장하지 않음

## Replicaset과 Deployment 구조

- Deploy
  - Replicaset
    - Pod

## Replicaset이란?

- Pod의 복제본(Replica)을 관리하고 장애 발생 시 자동 복구 수행
- 주요 역할:
  - 동일한 Pod를 원하는 수만큼 실행
  - Pod가 삭제되거나 비정상적으로 동작할 경우 자동으로 새 Pod 생성
- Pod와 Replicaset의 차이:
  - Pod는 단일 실행 단위로, 장애 발생 시 복구되지 않는다
  - Replicaset은 여러 Pod 복제본을 관리하고, 항상 원하는 수를 유지한다

## Replicaset의 주요 구성 요소

- replicas: 실행할 Pod의 개수를 정의
- selector: 관리할 Pod를 식별하는 기준(레이블 기반)
- template: 생성할 Pod의 템플릿(포함된 Pod 정의)

## Replicaset의 한계

- pod 복제와 복구에는 적합하지만, 업데이트와 롤백 같은 기능이 없다. → Deployment 리소스 개념 등장
