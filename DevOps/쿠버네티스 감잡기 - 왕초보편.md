# 쿠버네티스 감잡기 - 왕초보편

[유튜브 - 쿠버네티스 감잡기 - 왕초보편](https://www.youtube.com/playlist?list=PLeWIi-8hd-6WRfohXdF93aPfbaJdf6h96) 강의 정리

<br>

## 1강 - **쿠버네티스, 컨테이너, 도커 개념 감잡기**

### **컨테이너란?**

애플리케이션을 실행하는 데 필요한 모든 파일, 라이브러리, 설정 등을 하나의 패키지로 묶어 어떤 환경에서도 일관되게 실행될 수 있도록 만든 기술

#### **컨테이너 기술 특징**

1. **경량화**
   - 컨테이너는 OS를 공유하고, 필요한 최소한의 리소스만 사용하기 때문에 가볍다. 이로 인해 더 많은 애플리케이션을 하나의 서버에 실행할 수 있다.
2. **독립적 실행**
   - 컨테이너는 서로 격리되어 있어 한 컨테이너의 문제가 다른 컨테이너에 영향을 주지 않는다. → 안정성 향상
3. **이식성**
   - 컨테이너는 애플리케이션과 그 환경을 함께 묶어 어디서든 동일하게 실행할 수 있다.

### 도커란?

컨테이너를 쉽게 사용할 수 있게 만든 도구이자 플랫폼

#### **도커의 주요 역할**

- 컨테이너 이미지 생성
- 컨테이너 실행 및 관리
- 이식성 및 버전 관리

컨테이너 기술은 애플리케이션을 어떤 환경에서도 동일하게 실행할 수 있게 해주는 기술이고, 도커는 이를 편리하게 만들고 관리하는 도구

### 도커가 아닌 쿠버네티스인 이유?

**도커는 개별 컨테이너**를 쉽게 만들고 실행하는데 유용하지만, 많은 컨테이너를 클러스터 환경에서 자동화하고 **확장하여 운영할 때는 쿠버네티스**가 훨씬 효율적이다.

대규모 애플리케이션을 안정적으로 운영하기 위해서는 컨테이너 오케스트레이션 기능을 제공하는 쿠버네티스가 유리하다.

#### 컨테이너 이미지 실습

```bash
docker run —name web -d -p 80:80 nginx
docker run —name webserver -d -p 8080:80 httpd
docker run —name webserver2 -d -p 8001:80 httpd
```

#### 쿠버네티스 역할

1. **자동 배포 및 관리**

   애플리케이션을 여러 서버에 분산해 자동으로 배포하고, 필요한 경우 업데이트나 롤백을 쉽게 수행할 수 있도록 지원

2. **확장성 관리**

   사용량이 증가하거나 감소할 때 애플리케이션 인스턴스를 자동으로 늘리거나 줄여, 적절한 자원을 유지

3. **장애 복구**

   애플리케이션이 오류로 중단될 경우 자동으로 재시작하거나, 오류가 난 컨테이너를 다른 노드로 옮겨 문제없이 서비스가 유지되도록 한다

4. **리소스 관리**

   서버 자원을 효율적으로 분배하여 애플리케이션이 최적의 성능을 유지하도록 지원

### QnA

1. 컨테이너 기술에서 클러스터와 노드의 차이?

**클러스터(Cluster)**

- 컨테이너 실행을 위한 서버(노드)들의 집합
- 단일 서버가 아닌 여러 노드가 묶여 하나의 큰 시스템처럼 동작하는 그룹

**노드**

- 클러스터를 구성하는 개별 서버
- 컨테이너가 실제로 실행되는 단위

```bash
[ Cluster ]
   ├── Node 1
   │     ├── Container A  → (Image: nginx:latest)
   │     └── Container B  → (Image: redis:7)
   │
   ├── Node 2
   │     ├── Container C  → (Image: myapp:v1)
   │     └── Container D  → (Image: mysql:8.0)
   │
   └── Node 3
         ├── Container E  → (Image: myapp:v1)
         └── Container F  → (Image: nginx:latest)

```

- 이미지는 실행 파일(설치 패키지)
- 컨테이너는 그걸 실행한 실제 프로그램
- 노드는 컨테이너가 뛰는 서버
- 클러스터는 여러 노드를 통합 관리하는 그룹

<br>

## 2강 - **컨테이너 이미지, pull 주소 구조 감잡기**

> 컨테이너 이미지를 사용해 컨테이너를 실행한다?

### 컨테이너 기술

**애플리케이션과 그 실행 환경을 ‘컨테이너’라는 가상화된 공간에 패키징하는 기술**

컨테이너는 기존 가상 머신과는 다르게, **OS 커널을 공유**하면서 **서로 독립된 실행 환경을 제공**하여 더 경량화되고 빠르게 동작할 수 있다. 즉, 컨테이너는 애플리케이션 코드, 라이브러리, 종속성 등을 포함해 이를 배포할 때 일관되게 작동하도록 해준다.

### 컨테이너 이미지

**컨테이너 이미지는 컨테이너 실행에 필요한 모든 파일과 설정이 포함된 ‘템플릿’과 같은 역할**

이 이미지는 컨테이너의 상태와 환경을 일관되게 유지하는 데 사용되며, 개발자들이 구축한 환경 그대로를 배포할 수 있게 도와준다.

#### 주요 특징

- **불변성**
  컨테이너 이미지는 **읽기 전용**으로 저장되며, 생성 후에는 수정되지 않기 때문에 일관된 환경 보장
- **계층화**
  이미지는 여러 계층으로 이루어져 있으며, 각 계층은 특정 작업을 나타낸다.
  ex) 첫 계층은 운영체제, 그 위는 라이브러리 계층, 마지막은 애플리케이션 계층
  이 계층화 덕분에 이미지의 일부만 변경해도 전체 이미지를 다시 생성할 필요가 없다.
- **배포 용이성**
  컨테이너 이미지는 Docker Hub와 같은 **이미지 레지스트리**에 저장할 수 있어, 언제 어디서나 컨테이너로 실행할 수 있다.

### 컨테이너 이미지 pull 구조

```bash
docker pull redis
```

![docker-image-pull](https://imgur.com/fJrw3p5.png)

층을 하나씩 가져와서 완전한 이미지를 가져온다.

`pull` 할 때 사용하는 주소는 이미지가 **어디에 저장되어 있는지**, **어떤 이미지인지**를 명확히 지정하는 구조로 이루어져 있다.

```bash
<레지스트리 정보>/<이미지 이름>:<태그>
```

- <레지스트리 정보> 생략: 도커 허브
- <태그> 생략: latest 버전

```bash
docker pull jsregistry/myimg:1.0
docker pull nginx:1.24.3
```

<br>

## 3강 - 쿠버네티스 구조와 용어 감잡기

### 쿠버네티스 구조와 용어 설명

**쿠버네티스는 컨테이너화된 애플리케이션을 대규모로 배포하고 관리하기 위한 분산 시스템**

- **클러스터**: 컨테이너화된 애플리케이션을 관리하기 위한 컴퓨팅 리소스의 집합
- **노드**: 컨테이너를 실행하는 워커 머신으로, Pod가 배포되고 애플리케이션이 동작하는 실제 실행 환경
- **컨트롤 플레인**: 클러스터를 관리하고 조율하는 두뇌 역할

#### 클러스터

쿠버네티스 클러스터는 **여러 개의 노드로 구성**되며, **하나의 통합된 시스템처럼 작동**한다.

클러스터는 **다양한 노드 자원을 하나의 단위로 관리**하며, 애플리케이션의 배포와 관리를 최적화할 수 있는 환경을 제공한다.

구성: 컨트롤 플레인 / 워커 노드

#### 컨트롤 플레인

**클러스터의 상태를 제어하고 조정하는 핵심 구성 요소.**

클러스터의 상태를 관리하며, 애플리케이션이 원하는 대로 배포되고 운영되도록 유지한다.

- **API 서버**: **클러스터와 외부의 모든 요청을 관리하는 진입점**으로, 클러스터 내부의 리소스 상태를 조회하고 수정하는 인터페이스
- **스케쥴러**: 클러스터 내 워커 노드들에 애플리케이션을 배치하는 역할을 하며, 각 노드의 상태와 자원 사용량을 고려하여 최적의 위치를 선정한다.
- **컨트롤러 매니저**: 여러 컨트롤러를 통합 관리하며, 클러스터 내 **리소스가 사용자 지정 상태에 맞게 유지되도록** 한다.
- **etcd**: 모든 클러스터 사태 데이터를 저장하는 키-값 저장소로, **클러스터의 설정과 구성 정보를 영구적으로 보관**한다.

#### 노드

실제로 애플리케이션을 구동하는 클러스터의 구성 요소.

물리적 서버이거나 가상 머신일 수 있으며, 노드들은 워커 노드와 컨트롤 플레인으로 구성된다.

- **컨트롤 플레인(구 마스터 노드)**: 클러스터를 제어하고 관리하는 역할을 맡으며, 컨트롤 플레인에서 설명한 API 서버, 스케쥴러, 컨트롤러 매니저, etcd가 여기 위치한다.
- **워커노드**: 실제 애플리케이션을 구동하는 노드로, 각 애플리케이션의 컨테이너를 포함하는 Pod가 이곳에서 실행된다.
- 구성 요소:
  - **Kubelet**: 워커 노드의 **주요 에이전트**로, **API 서버와 통신하며, 노드에서 파드를 생성하고 유지한다.**
  - **컨테이너 런타임**: 컨테이너를 실행하는 데 필요한 환경을 제공하며, Docker, containerd 등이 이에 해당한다.
  - **kube-proxy**: 쿠버네티스 클러스터에서 서비스 트래픽을 적절한 Pod로 라우팅하고 로드 밸런싱을 수행하는 네트워크 중계자

<br>

## 4강 - 쿠버네티스 클러스터와 통신하는 방법 감잡기

### 쿠버네티스 클러스터 통신하는 방법

1. **Kubectl** ← 가장 일반적이고 공식적인 CLI 도구
2. Kubernetes Dashboard
3. REST API
4. Client Libraries(SDK) 등등

### kubectl이란?

- kubectl은 **클러스터의 API 서버와 통신**한다
- 모든 쿠버네티스 리소스는 API 서버를 통해 관리된다
- 사용자는 kubectl을 통해 명령어를 입력하면 API 서버에 요청을 보내고, 요청 결과를 받는다
- kubectl은 KUBECONFIG 파일을 사용하여 클러스터 접속 정보를 저장한다.

#### kubectl 특징

1. **클러스터 통신 구조**
   - kubectl은 쿠버네티스의 공식 CLI 도구로, 클러스터의 API 서버와 직접 통신한다.
   - 사용자는 kubectl 명령어를 입력하여 요청을 전송하고, API 서버로부터 결과를 수신한다.
2. **kubectl의 kubeconfig 파일**
   - 클러스터 접속 정보를 포함한 설정 제공
   - 기본 경로: ~/.kube/config
3. **kubeconfig 파일 내 주요 정보**
   - API 서버 URL
   - 사용자 인증 정보
   - 네임스페이스 정보

<br>

# 5강 - 쿠버네티스 실습환경 및 kubectl 자동완성 기능

> 도커 데스크탑 활용하기

## 도커 데스크탑 장점

- 쿠버네티스 클러스터 포함
- kubectl 포함

## 추가 환경설정

- kubectl 자동 완성 기능(쿠버네티스 CLI 명령어 자동 완성 기능)
  https://kubernetes.io/ko/docs/reference/kubectl/cheatsheet/
  - 긴 명령어/리소스/경로 탐색 등 tab 키로 자동 완성 및 오타 방지

```bash
source <(kubectl completion zsh)  # 현재 셸에 zsh의 자동 완성 설정
echo '[[ $commands[kubectl] ]] && source <(kubectl completion zsh)' >> ~/.zshrc # 자동 완성을 zsh 셸에 영구적으로 추가한다.

alias k=kubectl
complete -o default -F __start_kubectl k
```

![iterm-sample](https://imgur.com/UD5oB2m.png)

<br>

# 6강 - 쿠버네티스 파드란?

## 도커와 쿠버네티스의 차이점

- 도커에서는 컨테이너를 직접 배포하고 실행
- 쿠버네티스에서는 Pod라는 단위를 사용

### Pod란?

쿠버네티스에서 파드는 컨테이너의 집합으로, 애플리케이션을 실행하는 가장 작은 단위이다.

## Pod의 구조와 기본 개념

- **컨테이너 그룹**
  - Pod는 **하나 이상의 컨테이너를 포함**한다.
  - 동일한 Pod 내 컨테이너들은 네트워크와 스토리지를 공유한다.
- **네트워크**
  - Pod 내부의 컨테이너는 동일한 네트워크 네임스페이스를 공유하며, **localhost를 통해 서로 통신할 수 있다.**
- **스토리지**
  - Pod는 공유 볼륨을 사용하여 데이터를 컨테이너 간에 공유할 수 있다.(볼륨: 파드가 살아있는 동안 사용하는 공유 스토리지)

<br>
