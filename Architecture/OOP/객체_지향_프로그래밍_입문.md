# 객체 지향 프로그래밍 입문

[인프런 - 객체 지향 프로그래밍 입문 by 최범균](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/dashboard) 강의 정리

<br>

## 비용과 변화

개발이 진행될수록 비용이 늘어난다.

### 주요 원인

- 코드 분석 시간 증가
- 코드 변경 시간 증가

소프트웨어의 가치는 **“변화”** 다.

### 낮은 비용으로 변화할 수 있는 방법

- 패러다임
  - 객체지향, 함수형, 리액티브
- 코드, 설계, 아키텍처
  - DRY, TDD, SOLID, DDD, …
  - 클린 아키텍처, MSA
- 업무 프로세스/문화
  - 애자일
  - DevOps

<br>

## 객체

### 절차 지향

- 프로시저와 데이터 간의 접근이 자유롭다.
- 처음엔 수월하게 짤수있지만 시간이 지날수록 복잡해지고 수정이 어려워진다.

### 객체 지향

- 처음에는 데이터와 프로시저의 관계 처리가 어렵다.
- 시간이 지날수록 캡슐화 덕분에 빛을 본다.

### 객체

- 객체의 핵심은 **기능 제공**
  - 객체는 기능으로 정의
- 객체와 객체는 기능을 사용해서 연결
  - 기능 사용 = 메서드 호출
- 객체와 객체 상호 작용: 메시지를 주고 받는다고 표현

아래 클래스는 객체라기 보다 단순 데이터에 가깝다.
객체는 기능이 있어야 한다.

```java
public class Member {
    private String name;
    private String id;

    Getter, Setter
}
```

<br>

### 클래스

- 클래스는 데이터를 캡슐화하고 캡슐화한 데이터를 다루는 코드를 한곳에서 관리하는 것이다.

### 캡슐화(Encapsulation)

- 데이터 + 관련 기능 묶기
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
- 정보 은닉(Information Hiding) 의미 포함
- **외부에 영향 없이 객체 내부 구현 변경 가능**
  - 기능을 제공하고 구현 상세를 감춤
  - **연쇄적인 변경 전파를 최소화**
- 캡슐화 시도 → 기능에 대한 이해를 높임

### 캡슐화를 위한 규칙

- Tell, Don't Ask

  - 데이터 달라 하고 직접 비교하지 말고 그냥 해달라고 하기

```java
if(acc.getMembership() == REGULAR){
    ...
} // X
if(acc.hasRegularPermission()) {
    ...
} // O
```

- Demeter's Law

  - 메서드에서 생성한 객체의 메서드만 호출
  - 파라미터로 받은 객체의 메서드만 호출
  - 필드로 참조하는 객체의 메서드만 호출

```java
acc.getExpDate().isAfter(now) // X
acc.isExpired() // O

Date date = acc.getExpDate;
data.isAfter(now); // X
acc.isValid(now); // O
```

### 캡슐화 정리

- 캡슐화: **기능의 구현을 외부에 감춤**
- 캡슐화를 통해 기능을 사용하는 코드에 영향을 주지 않고(또는 최소화) 내부 구현을 변경할 수 있는 유연함

<br>

## 추상화

### 다형성(Polymorphism)

- 여러(poly) 모습(morph)을 갖는 것
- 객체 지향에서는 한 객체가 여러 타입을 갖는 것
  - 한 객체가 여러 타입의 기능을 제공
  - 타입 상속으로 다형성 구현(하위 타입은 상위 타입도 된다.)

### 추상화(Abstraction)

- 데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정
- 두 가지 방식의 추상화
  - 특정한 성질, 공통 성질(일반화)
- 간단한 예
  - DB의 USER 테이블: id, name, email
  - Money 클래스: 통화, 금액
  - 프린터: HP MXX, 삼성 SA-M2XX

### 타입 추상화

- 여러 구현 클래스를 대표하는 상위 타입 도출
  - 흔히 여러 인터페이스 타입으로 추상화
  - 추상화 타입과 구현 타입 상속으로 연결

### 추상 타입은 구현을 감춘다.

- 기능의 구현이 아닌 **목적을 더 잘 드러냄**

### 추상화는 의존 대상이 변경하는 시점에

- 추상화 → 추상 타입 증가 → 복잡도 증가
  - 아직 존재하지 않는 기능에 대한 이른 추상화는 주의: 잘못된 추상화 가능성, 복잡도만 증가
  - 실제 변경, 확장이 발생할 때 추상화

### 추상화를 잘 하려면

- 구현을 한 이유가 무엇 때문인지 생각해야 함

<br>

## 상속보단 조립

### 상속을 통한 재사용의 단점

- 상위 클래스 변경이 어려움
  - 상위 클래스 변경 시 하위 클래스에 영향을 끼침
  - 상위 클래스는 어떤 하위 클래스가 추가될지 모름
- 클래스 증가
  - 새로운 조합이 생길 때마다 새로운 클래스가 생김
  - 새로운 조합이 생길 때 어느 클래스를 상속받아야 할지 어려움
- 상속 오용
  - 실수로 상위 클래스의 메서드를 호출할 가능성이 있음

### 상속의 단점 해결 방법: 조립(Composition)

- 여러 객체를 묶어서 더 복잡한 기능을 제공
- 보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요 시점에 생성/구함

### 상속보다는 조립(Composition over inheritance)

- 상속하기에 앞서 조립으로 풀 수 없는지 검토
- 진짜 하위 타입인 경우에만 상속 사용

<br>

## 기능과 책임 분리

- 기능은 하위 기능으로 분해
- 기능은 곧 책임
  - 분리한 각 기능을 알맞게 분배

### 큰 클래스, 큰 메서드

- 클래스나 메서드가 커지면 절차 지향의 문제 발생
  - 큰 클래스 → 많은 필드를 많은 메서드가 공유
  - 큰 메서드 → 많은 변수를 많은 코드가 공유
  - 여러 기능이 한 클래스/메서드에 섞여 있을 가능성
- 책임에 따라 알맞게 코드 분리 필요

### 책임 분배/분리 방법

- 패턴 적용
  - 전형적인 역할 분리
    - 간단한 웹
      - 컨트롤러, 서비스, DAO
    - 복잡한 도메인
      - 엔티티, value, 레포지토리, 도메인 서비스
    - AOP
      - 공통 기능
    - GoF
      - 팩토리, 빌더, 전략, 템플릿 메서드, 프록시/데코레이터 등
- 계산 기능 분리
- 외부 연동 분리
  - 네트워크, 메시징, 파일 등 연동 처리 코드 분리
- 조건별 분기는 추상화
  - 연속적인 if-else문은 추상화 고민

### 역할 분리와 테스트

- 역할 분리가 잘 되면 테스트도 용이해짐

<br>

## 의존과 DI

### 의존

- **기능 구현을 위해 다른 구성 요소를 사용하는 것**
  - 의존의 예: 객체 생성, 메서드 호출, 데이터 사용
- 의존은 변경이 전파될 가능성을 의미
  - 의존하는 대상이 바뀌면 바뀔 가능성이 높아짐
    - ex) 호출하는 메서드의 파라미터가 변경
    - ex) 호출하는 메서드가 발생할 수 있는 익셉션 타입의 추가

### 순환 의존

- 순환 의존은 위험: 변경 연쇄 전파 가능성
  - 클래스, 패키지, 모듈 등 모든 수준에서 없도록 하자

## 의존 주입 DI

- 외부에서 의존 객체를 주입
  - **생성자**
  - 필드
  - setter
- DI의 장점
  - 상위 타입을 사용할 경우
    - 의존 대상이 바뀌면 설정(조립기)만 변경하면 됨
    - 의존하는 객체 없이 대역 객체를 사용해서 테스트 가능
- DI를 습관처럼 사용하기
  - 의존 객체는 주입받도록 코드 작성하는 습관

<br>

## DIP(Dependency Inversion Principle)

### 고수준 모듈

- 의미있는 단일 기능을 제공
- 상위 수준의 정책 구현

### 저수준 모듈

- 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현

### 고수준이 저수준에 직접 의존하면

- 저수준 모듈 변경 → 고수준 모듈에 영향

### 의존 역전 원칙

- **고수준 모듈은 저수준 모듈의 구현에 의존하면 안 됨**
- 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 함

### 고수준 관점에서 추상화

- 고수준 입장에서 저수준 모듈을 추상화
  - 구현 입장에서 추상화하지 말 것

### DIP는 유연함을 높임

- 고수준 모듈의 변경을 최소화하면서 저수준 모듈의 변경 유연함을 높임

<br>

## 참고

- [인프런 - 객체 지향 프로그래밍 입문 by 최범균](https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/dashboard)
